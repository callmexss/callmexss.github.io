---
title: 字符串的唯一最短前缀
date: 2019-07-23 17:12:05
categorises:
tags:
- bytedance
- string
- trie
---

输入第一行为一个整数，表示字符串的行数，接下来的 N 行每行为一个字符串。

输入：

```text
5
bytedance
toutiaohao
toutiaoapp
iesaweme
iestiktok
```

输出：

```text
b
toutiaoh
toutiaoa
iesa
iest
```

> 题目描述：找到输入中每个字符串的最短唯一前缀。
>
> 数据范围：N ≤ 1000，总字符数 < 1000000。
> 
> 输入数据确保没有一个字符串是另一个字符串的前缀。

思路是每个字符串和其他的所有字符串做比较，记录两个字符串间相同的位数，取其中的最大值作为字符串的唯一标识。

例如：

```python
word = 'bytedance'

other_words = [
    'toutiaohao',
    'toutiaoapp',
    'iesaweme',
    'iestiktok',
]

# b != t
# b != i
# loc = 0
print('bytedance'[:loc+1])
```

```python
word = 'toutiaohao'

other_words = [
    'bytedance',
    'toutiaoapp',
    'iesaweme',
    'iestiktok',
]

# for 'toutiaoapp':
# t == t
# o == o
# ...
# a == a
# o == o
# h != a
# loc = 7
print('toutiaohao'[:loc+1])
```

按照这种思路写出代码：

```python
def process(str_list):
    for word in str_list:
        # one char must be unique
        if len(word) == 1:
            print(word)
            continue
            
        # save the largest i for where the unique prefix ends
        saved_i = None
        for other_word in str_list:
            # not do self compare 
            if word == other_word:
                continue
            i = 0
            # find the first different char's location between word and other_word
            while i < len(other_word):
                if word[i] == other_word[i]:
                    i += 1
                else:
                    # find the first different char
                    if not saved_i:
                        # for the first inner loop
                        saved_i = i
                    else:
                        # update saved_i if current i is larger
                        saved_i = max(i, saved_i)
                    break
            # if other_word is a sub-string of word (this will not happed assured by the problem)
            # i will be len(other_word)
            # and the else part will never be reached
            # which means saved_i still is None
            # so check this case
            if i == len(other_word):
                saved_i = i

        print(word[:saved_i+1])
        continue


if __name__ == "__main__":
    # get toutal input count
    N = int(input())
    
    if N <= 0:
        exit()
    
    str_list = []
    for i in range(N):
        str_list.append(input().strip())  # read a word
        
    if N == 1:
        print(str_list[0][0])
    else:
        process(str_list)

```

更新一下字典树（前缀树）的解法：

{% asset_img trie-example.png %}

使用 `path` 记录经过节点的字母个数，当节点的 `path` 的值第一次为 1 时经过路径上的字符构成的字符串即为唯一最短前缀。

实现代码如下：

```python
class TrieNode:
    def __init__(self):
        self.path = 0
        self.end = 0
        self.maps = [None] * 26


class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        """Insert a word into trie tree.

        word: str, a word as string to inserted
        """
        if not word:
            return

        node = self.root
        node.path += 1  # this is actually the total number of words
        for c in word:
            # get the index of current char
            index = ord(c) - ord('a')
            # add a new trie node if current char first shown
            if not node.maps[index]:
                node.maps[index] = TrieNode()
            # else step into this char and update the path count
            node = node.maps[index]
            node.path += 1

        # hit the end of the word, mark it as end
        node.end += 1

    def search(self, word):
        """Check whether a word is in trie tree.

        word: str, a word as string to be searched
        """
        if not word:
            return

        node = self.root
        for c in word:
            index = ord(c) - ord('a')
            if not node.maps[index]:
                return False
            node = node.maps[index]
        return node.end > 0

    def get_shortest_unique_prefix(self, word):
        """Get the shortest unique prefix of a given word.

        word: str, a word as string to be searched
        """
        # this check should be done,
        # but i omit it here for convenient,
        # okkk... finally i did this.
        assert self.search(word) == True, "word is not in trie tree"
        # or should i insert it directly ???

        node = self.root
        shortest_unique_prefix = []
        for c in word:
            index = ord(c) - ord('a')
            shortest_unique_prefix.append(c)
            # note that the path of the first node
            # which actually is the root node's path
            # should not be checked and what we find
            # is the node whose path first equals one
            node = node.maps[index]
            if node.path == 1:
                return ''.join(shortest_unique_prefix)
        return word


class Solution:
    def process_via_trie(self, str_list):
        trie = Trie()
        for word in str_list:
            trie.insert(word)

        for word in str_list:
            shortest_unique_prefix = trie.get_shortest_unique_prefix(word)
            print(shortest_unique_prefix)


if __name__ == "__main__":
    # get toutal input count
    N = int(input())
    solution = Solution()
    if not N:
        exit()
    
    str_list = []
    for i in range(N):
        str_list.append(input().strip())  # read a word
    if N == 1:
        print(str_list[0][0])
    else:
        solution.process_via_trie(str_list)

```

然后测试的时候内存超过限制了...使用长度为 26 的列表会造成大量的空间浪费，尝试改成字典或者其他的数据结构应该可以优化空间的消耗。
