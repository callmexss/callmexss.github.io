---
title: 计算机网络实验——链路层、网络层
date: 2019-03-28 21:41:05
categorises:
tags:
- 计算机网络
- python
- scapy
- tcpdump
- docker
---

## 说明

实验主要来源于Rechard Stevens 的《TCP/IP illustrated》（《TCP/IP 详解》）卷一和刘超老师的极客时间专栏《趣谈网络协议》，实验网络拓扑基于docker搭建，github地址戳[这里](https://github.com/popsuper1982/tcpipillustrated)。

网络拓扑如下图所示：

{% asset_img 40-experiment_environment.jpg 实验的网络拓扑 %}

具体的搭建过程可以看刘超老师写的一篇博文：[有了Openvswitch和Docker，终于可以做《TCP/IP详解》的实验了！](https://blog.csdn.net/popsuper1982/article/details/79422735)。

脚本基本上是一键安装运行的，但是有一点要注意，就是下面的命令中，`./setupenv.sh`后面一定要跟你自己机器的网络接口（否则可能docker容器访问不了外网），例如我的机器是**eth1**，那么就是`./setupenv.sh eth1 hub.c.163.com/liuchao110119163/ubuntu:tcpip`。

```sh
git clone https://github.com/popsuper1982/tcpipillustrated.git
cd tcpipillustrated
docker pull hub.c.163.com/liuchao110119163/ubuntu:tcpip
chmod +x setupenv.sh
./setupenv.sh enp0s3 hub.c.163.com/liuchao110119163/ubuntu:tcpip
```

如果还有问题欢迎留言交流。

## 工具介绍

### docker

### tcpdump

### scapy

## 实验

### ARP实验

先来简单回顾一下ARP协议，它的全称是Address Resolution Protocol，中文名地址解析协议，作用是进行IP地址到MAC地址的映射。过程可以看下面两张图：

{% asset_img 5-arp_request.jpg ARP请求 %}

{% asset_img 5-arp_process.jpg ARP的过程 %}

ARP是基于以太网帧进行封装的，关于ARP协议具体工作与哪一层还有争议，网上一篇[博文](https://blog.csdn.net/ysdaniel/article/details/6785257)这个说法我认为比较合理：

> 可以这样说，在OSI模型中ARP协议属于链路层；而在TCP/IP模型中，ARP协议属于网络层。

不过除了考试做题，这个争议没用什么意义。比较关键的是以太网帧的结构，如下图所示：

{% asset_img 5-ethernet_frame_format.jpg %}

ARP报文在以太网帧的基础上进行封装，报文结构如下图所示：

{% asset_img 5-arp_packet_format.jpg %}

有了上面的基础，现在可以开始做实验了。

#### ARPPing实验

|   类别   | 主机名 |    接口地址   |
|:--------:|:------:|:-------------:|
|  源主机  |  bsdi  | 140.242.13.35 |
| 目的主机 |   sun  | 140.252.13.33 |

使用scapy可以很简单的进行ARPPing：

```python
# bsdi
# `srp` means send and receive packet
# ethernet frame `dst` field is broadcast
# arp packet encapsulated in ethernet frame data
# send arp packet from bsdi to sun
>>> ans, unans = srp(Ether(dst="ff:ff:ff:ff:ff:ff") / ARP(pdst="140.252.13.33"))
Begin emission:
*Finished sending 1 packets.

Received 1 packets, got 1 answers, remaining 0 packets

# inspect ans
>>> ans
<Results: TCP:0 UDP:0 ICMP:0 Other:1>

# from the output of srp we can see that
# a packet was sent and a packet was received
# see ans.summary()
# it was the request and response of a arp process
>>> ans.summary()
Ether / ARP who has 140.252.13.33 says 140.252.13.35 ==> Ether / ARP is at 86:43:ab:ea:6e:96 says 140.252.13.33

# see the content of the ans tuple
# ans[0][0] is the arp request
# ans[0][1] is the arp reply
>>> ans[0]
(<Ether  dst=ff:ff:ff:ff:ff:ff type=0x806 |<ARP  pdst=140.252.13.33 |>>,
 <Ether  dst=02:1c:55:0e:bb:87 src=86:43:ab:ea:6e:96 type=0x806 |<ARP  hwtype=0x1 ptype=0x800 hwlen=6 plen=4 op=is-at hwsrc=86:43:ab:ea:6e:96 psrc=140.252.13.33 hwdst=02:1c:55:0e:bb:87 pdst=140.252.13.35 |>>)

# see the request packet format
# the `dst` field is a broadcast address
# notice that the `type` field is 0x0806
# which means arp
# hwtype(hardware type) value 1 means ethernet
# ptype(protocol type) value 0x0800 means IP
# hwlen should be 6(length of MAC address)
# plen should be 4(length of IP addres)
# op `who-has` means request opreation
>>> ans[0][0].show()
###[ Ethernet ]###
  dst= ff:ff:ff:ff:ff:ff
  src= 02:1c:55:0e:bb:87
  type= 0x806
###[ ARP ]###
     hwtype= 0x1
     ptype= 0x800
     hwlen= None
     plen= None
     op= who-has
     hwsrc= 02:1c:55:0e:bb:87
     psrc= 140.252.13.35
     hwdst= None
     pdst= 140.252.13.33

# see the reply packet format
# its `dst` field is the `src' filed of request packet
# `type` is also 0x806
# op `is-at` means arp reply
>>> ans[0][1].show()
###[ Ethernet ]###
  dst= 02:1c:55:0e:bb:87
  src= 86:43:ab:ea:6e:96
  type= 0x806
###[ ARP ]###
     hwtype= 0x1
     ptype= 0x800
     hwlen= 6
     plen= 4
     op= is-at
     hwsrc= 86:43:ab:ea:6e:96
     psrc= 140.252.13.33
     hwdst= 02:1c:55:0e:bb:87
     pdst= 140.252.13.35
```

使用tcpdump在sun端进行抓包：

```sh
# -i select interface
# -n do not resolve IP address
root@70aa710235b6:$ tcpdump -i eth1 -n
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth1, link-type EN10MB (Ethernet), capture size 262144 bytes
00:35:44.116294 ARP, Request who-has 140.252.13.33 tell 140.252.13.35, length 42
00:35:44.116317 ARP, Reply 140.252.13.33 is-at 86:43:ab:ea:6e:96, length 28

# add -vv
root@70aa710235b6:$ tcpdump -i eth1 -n -vv
tcpdump: listening on eth1, link-type EN10MB (Ethernet), capture size 262144 bytes
00:50:14.050065 ARP, Ethernet (len 6), IPv4 (len 4), Request who-has 140.252.13.33 tell 140.252.13.35, length 42
00:50:14.050087 ARP, Ethernet (len 6), IPv4 (len 4), Reply 140.252.13.33 is-at 86:43:ab:ea:6e:96, length 28
```

本实验使用scapy构造并发送了一个简单的ARP报文，并在目标主机使用tcpdump进行了抓包操作。主要是为了对ARP协议的功能和报文的结构有一个直观的认识。完整的ARPPing实际可以一次性对一个网段内的所有主机进行进行Ping测试，scapy代码如下：

```python
# arp ping to subnet 140.252.13.32-63
# net 140.252.13.32
# mask 255.255.255.224
>>> ans, unans = srp(Ether(dst="ff:ff:ff:ff:ff:ff")/ARP(pdst="140.252.13.32/27"),
                     timeout=2)
Begin emission:
**Finished sending 32 packets.

Received 2 packets, got 2 answers, remaining 30 packets

>>> ans.summary()
Ether / ARP who has 140.252.13.33 says 140.252.13.35 ==> Ether / ARP is at 86:43:ab:ea:6e:96 says 140.252.13.33
Ether / ARP who has 140.252.13.34 says 140.252.13.35 ==> Ether / ARP is at 22:8a:5c:68:86:ec says 140.252.13.34

```

{% asset_img arpping.jpg ARPPing 140.252.13.32/27 %}

结合实验拓扑可以看出结果符合预期。子网140.252.13.32/27可以表示为140.252.13.001 00000，bsdi主机的一个网卡接口的IP地址为140.252.13.001 00011，sun主机的一个网卡接口的IP地址140.252.13.33/27表示为140.252.13.001 00001，svr4主机的一个网卡接口的IP地址可以表示为140.252.13.001 00010，根据子网划分的规则可以看出bsdi、sun和svr4都属于同一个子网。而主机slip的网卡接口的IP地址表示为140.252.13.010 00001，不属于子网140.252.13.001 00000。因此从bsdi发起的ARPPing应该能收到sun和svr4的ARP响应，但是收不到slip的ARP响应。

| 子网号 | 140.252.13.32/27 | 140.252.13.001 00000 |
|:------:|:----------------:|:--------------------:|
|  bsdi  | 140.252.32.35/27 | 140.242.13.001 00011 |
|   sun  | 140.252.32.33/27 | 140.252.13.001 00001 |
|  svr4  | 140.252.32.34/27 | 140.252.13.001 00010 |
|  slip  | 140.252.32.65/27 | 140.252.13.010 00001 |

#### 使用telnet连接无效服务器



### IP实验

#### bsdi向sun发送数据包

在主机bsdi使用scapy构建IP数据包，并发送到sun：

```python
packet = IP(dst="140.252.13.33")
send(packet)
```

在sun使用tcpdump进行抓包：

```sh
# -i 用于指定接口
# -n 不进行IP到域名的转换
# ip 指定ip协议
tcpdump -i eht1 -n ip
```

### ICMP实验